# Java内存管理与垃圾回收机制

标签： JVM

---
##1. 运行时数据区域
JVM中的运行时数据区如下图所示：

![Image text](image/1.png)

>
一般程序员们喜欢把虚拟机的运行时数据区分成**堆和栈**，然而这只是运行时数据区的一部分，只是人们比较关注这两个区域。其中的堆用于分配对象，而这里的栈主要指的是虚拟机栈中的局部变量表部分。

下面将分别对这些数据区域进行解析。
#### 1.1 程序计数器
<span id="#1.1"></span>
程序计数器是内存中一片很小的数据区，他可以看作为当前线程的字节码执行的行号，字节码解释器通过改变程序计数器的值，来选取下一条要执行的字节码指令，推进程序的执行。

每一个线程都要有一个独立的程序计数器。如果当前执行的是一个Java方法，这个计数器记录的就是正在执行的字节码指令的地址。如果执行的是一个Native方法，则其内容为Null。

#### 1.2 Java虚拟机栈

Java虚拟机栈也是一个线程私有的数据区。

Java虚拟机栈描述了**Java方法执行**的内存模型，每当一个方法被调用的时候，都会有一个相应的**栈帧**进栈，这个栈帧用于存储:
>
* 局部变量表
* 操作数栈
* 动态链接
* 方法出口信息
* el at.

一个方法从入栈到出栈的过程就对应着这个方法从开始执行到返回的过程。其中一个比较重要的区域是局部变量表。

**`局部变量表`**存放了`编译期`可知的各种基本类型(byte, boolean, char, short, int, long, float, double)、对象引用和returnAddress类型（指向一条字节码指令地址）。
其中long和double会占用2个局部变量空间(Slot)，其余的类型只占用一个。局部变量表的分配在`编译期间`分配，当进入一个方法的时候，局部变量表的大小是完全确定的。在方法的运行期间不会对局部变量表的空间进行改变。

在该区域有两种异常：`StackOverflowError`和`OutOfMemoryError`。前者在线程请求的栈深度大于虚拟机所允许的深度的时候抛出，而虚拟机也支持动态扩展，如果在动态扩展的时候无法申请到足够的内存，则会抛出OutOfMemoryError。

#### 1.3 本地方法栈

本地方法栈起到的作用域虚拟机栈的作用相仿，不过这个栈是在执行Native方法的时候使用的。这个区域也有虚拟机栈会抛出的两种异常。

#### 1.4 Java堆

Java对是所有线程共享的一块空间，堆的唯一目的就是存放对象的实例。虽然JVM规范中规定的是“所有的对象以及数组都要在堆中分配”，但是现在也不是那么绝对了。

Java堆也是垃圾收集和管理的主要区域。Java堆在空间上可以不连续，只要逻辑上是连续的即可。当前主流的Java虚拟机的堆都是可扩展的，（可以通过`-Xmx`和`-Xms`）来控制。关于Java对象的创建和回收我们将在后面详细探讨。

#### 1.5 方法区(Method Area)

方法区是一块线程共享的区域，方法区类似于传统编程语言的存储编译后的代码的存储空间，或者是操作系统的“text”段。

它存储了每个类的结构，比如运行时常量池、静态域、方法数据以及方法和构造器的代码。

> ***运行时常量池***
> 
> 运行时常量池是每个类或每个接口的class文件中的constant_pool表的表示，其中的常量包括了方法中*编译期可知*的**数值型字面量**(numeric literals)和*在运行期必须解析*的域的引用(field reference)。当然，运行时常量池中的内容是可以在程序运行时动态添加的，可以算是class文件常量池的扩展（如翻译出来的直接引用、String.intern()生成的字符串等）。

>运行时常量池的作用类似于传统编程语言的符号表，但是运行时常量池中包含的数据的范围比传统符号表更广一些。

>异常：在创建类和接口的时候，如果运行时常量池需要的空间比JVM分配给方法区的空间还要大的话，JVM会抛出OutOfMemoryError
>
>来源：https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.4

扩展：字符串与常量池-https://blog.csdn.net/sugar_rainbow/article/details/68150249

对这个帖子的内容进行一下精简：

>* 在方法和域中的*字符串常量*都是在编译的过程中放入运行时常量池的；
>* 对于类似`str="GC"+"reclaim"`的字符串拼接，在常量池中只有直接生成的GCreclaim。但是如果是`str1="GC";str2="reclaim";str3=str1+str2;`的话，运行时常量池中只有GC和reclaim，而没有拼接后的字符串
>* 如果用了`str1="GC";
>str2=new String("GC");
>str3=new String("abc");
>str1==str3;// false`
>这种情况下运行时运行时常量池中会有GC和abc两个字符串，这是编译期放进去的，运行期才会生成new的对象，而这个对象会生成在堆中，因而返回false；
>* JDK1.7中JVM把String常量区从方法区中移除了；JDK1.8中JVM把String常量池移入了堆中，同时取消了“永久代”，改用元空间代替（Metaspace）

#### 1.6 直接内存
直接内存并不是虚拟机的一部分，但是这部分也有可能被频繁的使用，而且有可能抛出OutOfMemoryError。在使用NIO的时候，引入了基于Channel与Buffer的IO机制，它使用Native函数在堆外直接分配内存。如果对这部分内存缺乏管理而使得这部分的使用量超过了物理限制，则会抛出OutOfMemoryError。

## 2. Java虚拟机对象
####2.1 对象的创建
*注：这部分只针对一般的Java对象，而不包括数组、class对象等。*

1. 首先，在虚拟机的执行过程中遇到关键词`new`的时候，先去检查运行时常量池，看是否能在其中找到对应类的符号引用，并检查其对应的类是否被加载、解析和初始化过。若没有，限制性加载过程。
2. 为对象分配内存：类在被加载之后，其实例所需要的空间大小就确定了，需要在堆中把一个相应大小的区域划分出来。分配的方法有**指针碰撞**和**空闲列表**等方法，使用哪种方法取决于Java堆中的空间是否规整。同时，为了解决并发情况下的分配问题，有对分配操作进行同步处理的方式(大多使用CAS)和为每个线程分配本地线程缓冲的方式(在分配新TLAB时才需要同步)。
3. **实例字段**初始化零值（不包括对象头）。如果使用了TLAB，则这个过程可提前到TLAB分配时进行。
4. 设置对象的对象头(Object head)：其中的信息包括这个对象是哪个类的实例、如何找到类的元数据、对象的哈希码、对象的分代年龄等信息。<font color=red>后续会讲到锁与对象头的关系。(留个坑)</font>
5. 执行<init\>方法,按照程序员的意愿对类进行初始化。
> 关于类准备和实例初始化：创建对象时的初始化与类加载时的准备不同，类加载时的初始化先为**类变量**赋初始值（一般为0，而不是我们写的值），如果有static final的变量，则将其值初始化为我们写的值。真正为类变量赋值的过程在类加载的初始化阶段。

#### 2.2 对象的内存布局

在HotSpot虚拟机中，对象有三个区域：对象头、示例数据和填充。

- 对象头：对象头包括`Mark Word`和`类型指针`。
- 实例数据：在程序代码中定义的各种类型的字段内容。
- 填充：HotSpot规定对象大小必须为8字节的整数倍。

#### 2.3 对象访问定位

有指针访问方式和句柄访问方式两种。

- 如果使用句柄方式的话，Java堆需要分出一片区域作为句柄池，而栈中的reference存储的是句柄地址。句柄中包括了对象实例数据的地址以及对象类型数据的地址。如下图所示：
![](image/2.png)

- 而如果使用直接指针法，则堆中的对象就必须考虑如何访问类型数据。如下图所示：
![](image/3.png)

两种方式各有所长，句柄方式在垃圾回收对象移动后只改变句柄中的实例地址，而reference不需要改变。而直接指针则有着访问速度快的优势。

## 3. 垃圾回收器

程序计数器、虚拟机栈和本地方法栈3个区域都是随着线程的创建而创建，随着线程的结束而销毁。栈中的栈帧随着方法的进入和退出有条不紊的执行者入栈和出栈操作，每一个栈帧中分配多少内存基本上都是在类结构确定的时候定下来的。但是Java堆以及方法区却不是这样，