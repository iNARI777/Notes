# 虚拟机字节码执行引擎

## 1. 概述

“虚拟机”是一个相对于“物理机”的概念，两种机器都有执行代码的能力。物理机的执行引擎直接建立在处理器、硬件指令集和操作系统层面，而虚拟机执行引擎则是由自己实现的，因此可以自行制定指令集与执行引擎的体系结构，并且能够执行那些不被硬件直接支持的指令集格式。

在虚拟机中执行Java代码的时候，可能会有解释执行和编译执行，也可能两者兼有。Java虚拟机的执行模型都是一样的，输入字节码，处理过程是字节码解析的等效过程，输出的是执行结果。

## 2. 运行时栈帧结构

**栈帧**是用于支持虚拟机执行**方法调用**和**方法执行**的数据结构。它是运行时数据区虚拟机栈中的元素。每个方法调用都对应一个栈帧从入栈到出栈的过程。

栈帧中存储了**局部变量表**、**操作数栈**、**动态链接**以及**方法返回地址**等信息。栈帧中需要多大的局部变量表、多深的操作数栈都是在**编译期**确定的，并且写入到**Code属性**之中。

![](image/execute/1.jpg)

由于一个线程中的方法调用链可能很长，对于执行引擎来说，在活动线程中只有栈顶的栈帧才是有效的。

### 2.1 局部变量表

是一组变量存储空间，用于存放**方法参数**和方法内定义的**局部变量**。局部变量表大小在编译时确定，存放在方法集合表的Code属性的max_locals中。

局部变量表的容量以变量槽(Slot)为单位，JVM规范中只规定了一个Slot中能够存放1个boolean、byte、char、short、int、float、reference或returnAddress的。returnAddress现在已经很少见。而double和long类型的数据可以由两个连续的Slot来存放，这里可以与JMM中的“long和double的非原子性协定”相比较。

> reference引用的作用：
> 1. 可以通过此引用直接或间接地找到对象在Java堆中的数据存放的起始位置；
> 2. 可以通过此引用直接或间接地找到对象所属的类型再方法区中的位置。

虚拟机通过索引定位的方式使用局部变量表。索引范围是0到变量表的最大值。其中第0个Slot存放this，后面的Slot依次存放方法参数，再后面的Slot存放方法内定义的局部变量。为了节省空间，Slot是可以重用的。

Slot重用可能会造成垃圾回收的一些问题。局部变量出了其作用域之后如果没有后来的变量覆盖这一个Slot的话，这个Slot不一定会被清除，因此在GC ROOT中还是可以找到堆中相应的变量，造成出了作用域，但是对内对象仍然未回收的情况。代码如下：

	public static void main(String[] args) {
		{
			byte[] placeholder = new byte[64 * 64 * 1024];
		}
		//int a = 0; ===> 如果不加这句代码，placeholder的slot就不会被覆盖
		System.gc();

一般解决这种问题的方法是将变量置为null，但是其实这种问题不一定会出现，因为上述执行过程是根据字节码解释执行的时候的概念模型，但是Java虚拟机经过JIT编译才是主要的执行方式，编译为本地代码之后，GC的行为其实是有很大不同的。

### 2.2 操作数栈

JVM的执行引擎是基于栈的执行引擎，其中的栈就是指的操作数栈。它是一个后入先出(LIFO)栈，其大小同局部变量表一样，操作数栈深度在编译的时候也被写入了Code属性中。

操作数栈的每个元素可以是任意的Java类型，32位数据占的栈容量是1,64位的是2。在方法执行的过程中会有各种字节码指令向操作数栈中存放或提取内容。存放和提取的数据类型是字节码制定好的，不会出现歧义。

在逻辑上，两个栈帧是相互独立的，但是在具体实现的时候，会有一些优化，会让下面的帧的操作数栈与上面的帧的局部变量表重叠，以减少数据的传输。

### 2.3 动态链接

每个栈帧都包含一个指向运行时常量池中该栈帧所对应的方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。

我们知道，在Class文件的常量池中，保存着大量的符号引用，字节码中的方法调用指令就是以这些常量池中的符号引用作为参数的。

这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这就是**静态解析**，另外一部分将在每一次运行的时候都转化为直接引用，这是**动态解析**。

### 2.4 方法返回地址

一个方法开始执行后，有两种方法可以返回。第一种是执行引擎遇到任意一个方法返回的字节码指令，这个时候可能有返回值返回给调用者，这种方式是正常完成出口。第二种是在方法执行过程中遇到了异常，并且这个异常没有在方法中得到处理，只要在方法的异常表中没有找到匹配的异常处理器，就会导致方法的退出，这种退出时异常完成出口。它不会给调用者任何返回值。

一般来说，正常退出时调用者的PC值可以作为返回地址，这通常被存在被调用者的**栈帧**中。而非正常退出的时候，返回地址通过异常处理器表来确定，这部分信息**一般不在栈帧中**。

综上，方法退出的时候可能执行的操作有：
1. 回复上层方法的局部变量表和操作数栈；
2. 将返回值压入调用者栈帧的操作数栈中；
3. 调整PC值，使得PC计数器的值指向下一条指令等。

### 2.5 附加信息

虚拟机的具体实现还会在栈帧中添加一些JVM规范中没有描述的信息，比如调试相关信息等。

## 3. 方法调用

方法调用阶段的唯一任务就是确定方法调用的版本（即调用哪一个方法），但是不涉及方法内部的具体运行过程。

由于Class文件在编译的过程中没有传统语言编译过程中的连接过程，**一切方法调用在Class文件中存储的都是符号引用**，而不是直接引用（即方法运行时内存布局中的入口地址），这一点使得Java方法调用有了极大的灵活性，但是也增加了方法调用过程的复杂程度。需要在**类加载**期间甚至是**运行期**才能确定方法的直接引用。

### 3.1 解析

解析调用是一种静态过程，在**编译期就完全确定**，在**类加载的解析阶段就可以把涉及到的符号应用转化为直接引用**，不会延迟到运行期再完成。

在Java语言中符合“编译期可知，运行期不变”要求的方法主要包括**静态方法**和**私有方法**，前者与类型直接关联，而后者不可在外部被访问，这就决定了它们不可能通过继承或者别的方式重写其他版本。

与方法调用相关的字节码指令有以下5条：
1. invokestatic：调用**静态方法**；
2. invokespecial：调用**实例构造器\<init>方法**，**私有方法**和**父类方法**；
3. invokevirtual：调用**虚方法**；
4. invokeinterface：调用**接口方法**，在运行时再确定一个实现此接口的对象；
5. invokedynamic：在运行时动态解析出调用点限定符所引用的方法，与前4条指令分派逻辑固化在JVM内部不同，这条指令的分派逻辑由用户设定的引导方法决定。<font color=red>(不太明白)</font>

被`invokestatic`和`invokespecial`调用的方法都可以在解析阶段确定方法调用的版本。这些方法被称为非虚方法，其他方法（除了final方法以外）的方法都被成为虚方法。虽然使用final修饰的方法使用invokevirtual调用，但是由于其无法被覆盖，所以无需进行多态的选择，Java语言规范中明确规定了final方法是非虚方法。

### 3.2 分派

首先明确两个概念：重载和覆盖。这两者是多态特征的最基本体现。

**重载(overload)**：指的是一个类中方法名相同，而接受的参数不同（个数不同、类型不同、顺序不同，但是返回值在Java语言中不能作为重载的依据）。

**覆盖(override)**：指的是子类中定义的方法要与父类中完全相同（方法签名相同，返回值相同，抛出异常类型范围更小，访问权限更加宽松，父类中的private方法不能覆盖）。

#### **静态分派**：

概念：所有**依赖静态类型来定位方法执行版本**的分派动作就是静态分派，其典型应用是**方法重载**。

> 静态类型指的是引用变量的类型，比如说`Parent p = new Child();`中的静态类型就是Parent。

发生时间：静态分派发生在**编译阶段**，所以静态分派并不是由虚拟机来进行的。

有一个要注意的地方就是字面量没有显式的静态类型，在使用字面量进行静态分派的时候只能确定一个“更加合适的版本”。如果编译器无法确定调用的版本，就会拒绝编译（比如实现了两个接口的类）。

#### **动态分派**：

概念：动态分派是根据变量的实际类型的不同而进行方法版本选择。

发生时间：发生在**运行阶段**。

invokevirtual指令的运行时解析过程大致可以分为如下几部：
1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C；
2. 如果在类型C中能够找到与常量中的**描述符**和**简单名称**相符的方法，则进行访问权限检查，如果通过，则返回这个方法的直接引用；如果未通过，抛出IllegalAccessError异常；
3. 否则按照继承关系从下往上依次对C的父类进行第2步的搜索和验证过程；
4. 如果没有找到合适的方法，抛出AbstractMethodError异常。

#### **单分派与多分派**：

宗量：方法的接受者与方法的参数统称为方法的宗量。

根据分派基于多少种宗量，可以将分派划分为单分派与多分派。具体的例子可以参见书中P255中的例子。

Java是“静态多分派，动态单分派”的语言。

#### **虚拟机动态分派的实现**：

在动态分派一节中已经说明了在动态分派的概念上应该进行的4个步骤，但是在实际实现的角度考虑，这种频繁的搜索非常影响性能。所以通常会在类的**方法区**中建立虚拟方法表（如果使用invokevirtual的话就是用接口方法表）的方法进行优化。

虚方法表中存放着各个方法的实际入口，如果某个方法在子类中没有被重写，那子类的虚方法表里的方法入口地址就和父类填入相同的地址。

方法表一般在类加载的连接阶段进行初始化，准备了类变量的初始值之后，虚拟机就会把类的方法表也初始化完毕。

# 参考资料
[1] 深入理解Java虚拟机——JVM高级特性与最佳实践