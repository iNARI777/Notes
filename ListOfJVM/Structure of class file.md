# Class文件结构

我们要知道Java虚拟机不和任何一种语言绑定，它只与“Class文件”这种特定形式的二进制格式文件有关联。不管是Java还是JRuby、Scala、Groovy，都是要被对应语言的编译器编译为Class文件，才能使用JVM执行。

下面就来看看Class文件的结构。

## 1. Class文件结构

任何一个Class文件都唯一对应一个类或者一个接口，但是一个类或者接口不一定对应一个Class文件，因为类或者接口可以改通过类加载器直接生成。

Class文件是一组以字节为基础单位的二进制流，当遇到所占空间在1个字节以上的结构的时候，会按照高位字节存储在低位地址（也就是 **大端法** ）进行存储。Class文件的结构十分紧凑，其没有任何分隔符，它的每一个字节的作用都是规定好的。

在Class文件中使用类似于C语言的结构体来进行数据的存储，在这个结构体中，只有两种数据类型： **无符号数** 和 **表**。

* 无符号数：属于基本类型，以u1，u2，u4和u8来代表占1/2/4/8个字节的无符号数。无符号数可以表示*数字*、*索引引用*、*数量值*或者UTF-8编码构成的*字符串值*。
* 表：由无符号数或者其他表作为数据项而组成的复合数据结构，习惯以*_info*结尾。Class文件的本质其实就是一张表。

无论是无符号数还是表，当需要表示多个同类型的数据但是个数不确定的时候，这个结构的前面都会有一个前置的容量计数器，后面跟着这个数据结构。

接下来，将按照数据在Class文件中的顺序，对Class文件的每一个部分进行描述。

#### 1.1 魔数与Class文件的版本

魔数：在Class文件的最前面用来表示该文件是一个可以被虚拟机接受Class文件，这个魔数由四个字节组成，其值为0xcafebabe，这也是Java的咖啡图标的由来。

版本号：紧跟着魔数的四个字节就是版本号，其前两个字节是次版本号(Minor Version)，后两个字节是主版本号(Major Version)。高版本的JVM可以向下兼容以前的版本，但是不能运行以后版本的Class文件，哪怕Class文件的内容一样。

#### 1.2 常量池

版本号之后的内容就是常量池的入口。

它是Class文件中与其他项目关联最多的数据类型，也是占用空间最大的结构之一，它也是Class文件中出现的第一个表类型的数据。

**常量池容量计数器(constant_pool_count)**：前面提到过，一个项目数不确定的结构的前面会有一个容量计数器，常量池就是如此。常量池的容量计数器有一个特殊之处，就是**其开始的值是1**，而不是0，它以1代表0，也就是说，常量池中常量的数量是容量计数器的值减1。这么做的目的是有的时候需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把计数器的值置0。在Class文件中只有这一项有这一特殊表现，而其他项的容量计数器仍然以0开头。

**常量池中的常量**：常量池中主要存放两种常量——**字面量**(Literal)和**符号引用**(Symbolic References)。字面量接近Java语言层面的概念，如文本字符串，声明为final的常量值等。符号引用则是编译原理方面的概念，其包括：

* 类和接口的全限定名
* 字段的名称和描述符
* 方法的名称和描述符

Java与C/C++不同，编译过程没有链接这一步骤，链接实在虚拟机加载Class文件的时候动态进行的，在虚拟机运行的时候加载常量池中的符号引用，在创建类或者运行的时候将其翻译到具体的内存地址。这部分内容将在后续的章节进行解释。

常量池中的每一项常量都是一张表，表的开始是一个u1类型的标志位，每一种标志表示一种类型的数据，共有14种数据，他们的结构各不相同。如下两图所示：

![](image/class/1.png)

![](image/class/2.png)

> 题外话：方法名或者变量名等都会指向一个CONSTANT_Utf8_info，它是由1个u1的tag、1个u2的length和u1的bytes组成，其中的length表示字符串由多少个UTF8编码后的字节组成，因此如果方法、字段名的大小大于了64KB，将会无法编译。

具体每种表项的结构见《深入理解Java虚拟机》的P172。

#### 1.3 访问标志

在常量池后面的两个字节是访问标志，它由16个标志位可以使用，但是当前之定义了8个。没使用到的标志位一律置0。

![](image/class/3.png)

#### 1.4 类索引、父类索引与接口索引集合

类索引(this_class)和父类索引(super_class)都是一个u2类型的数据，而接口索引集合(interfaces)是一组u2类型的数据集合。在Class文件中同个这三个数据来确定这个类的继承关系。

#### 1.5 字段表集合

字段表(field_info)用于描述接口或类中声明的变量。字段包括类级变量以及实例级变量，但是不包括在方法中声明的变量。

一个字段通常包含的信息有：
* 作用域(public priavte protected)
* 类变量或实例变量(static)
* 可变性(final)
* 并发可见性(volatile)
* 可序列化性(transient)
* 字段数据类型
* 字段名

后两个信息无法通过固定的形式表现，所以只能引用常量池中的常量进行表示。**也就是说这两项都是常量池中的字符串！**

![](image/class/4.png)

字段表集合的前两个字节是access_flag，其包含了这个字段的**前四种信息**，紧随其后的是name_index和descriptor_index，他们都是对常量池的引用，代表字段的**简单名称**以及**字段和方法的描述符**。

而其中的描述符比较复杂，其作用是用来描述**字段的数据类型**、**方法的参数列表**和**返回值**。每种数据类型都有其特定的描述符，如下图所示：

![](image/class/5.png)

对于方法的描述符来说，按照先参数列表、而后返回值的顺序描述，参数列表按照严格的顺序放在括号()中。如下图所示：

![](image/class/6)

关于attribute_info的内容会在第7节中涉及。

字段表集合中不会列出从超类或接口中继承的字段，但是有可能列出原本Java类中不存在的字段，比如内部类中会自动生成外部类对象的引用字段。

**Class文件中字段的“重载”是被允许的**：在Java中字段是不可以重载的，但是在Class文件中，两个字段名称相同，但是描述符不同是合法的。

#### 1.6 方法表集合

方法表集合的结构和字段表集合的结构几乎一样，且每一项的含义也基本相同，仅在访问标志和属性表集合的可选项中有区别。

与字段表集合相同，如果本类中没有覆盖父类中的方法，方法表中就不会出现父类中的方法信息，同样，编译器可能会在其中添加Java类中不存在的方法，典型的就是类构造器<clinit>和实例构造器<init>两个方法。

**Class文件中方法的重载的不同**：在Java中是无法靠返回值的不同来进行重载的，但是在Class文件中是可以的。Java中的方法特征签名包括方法名称、参数顺序及参数类型，但是字节码中的特征签名还包括了方法返回值以及受查异常表。