# 锁与事务隔离级别

之前中写到了四种事务隔离级别下可能出现的脏读、幻读、不可重复读的问题，引起这些问题的原因就是数据库在不同隔离等级下采用的加锁策略不同。我们在书上可以看到很多笼统的说 MySQL InnoDB 中“读加共享锁、写加排它锁”、“InnoDB 中加锁的算法有 record 、 gap-lock 、 next record”、以及 MVCC 等一些非常玄乎的东西。这篇笔记中，我们就试着梳理一下不同事务隔离级别下 MySQL InnoDB 中加锁的不同策略。

## 1. 基础回顾

我们都知道事务隔离级别分为四种： **未提交读(Read Uncommitted)**、**提交读(Read committed)**、**可重复读(Repeatable read)** 以及**串行化(Serializable)**四种，其中未提交读有 **脏读** 的问题，提交读有 **不可重复读** 的问题，可重复读有着 **幻读** 的问题，而串行化以最差并发性为代价解决了上述所有问题，那么脏读、不可重复读以及幻读具体都指的是什么呢？

首先明确一下，以上几个问题虽然都带着一个“读”字，但并不代表只有在 `SELECT` 的时候才会出现这些问题。这里的读指的更多是在事务中执行 SQL 的时候这条 SQL 可以“意识到”某一条记录的存在。比如说在我的一张表中有一条主键为 4 的记录，然后我再插入一条主键为 4 的记录的时候，这条 INSERT SQL 是能够“意识到”已经有一个主键为 4 的记录存在，所以插入失败了，可以说这条 SQL “读” 到了那条主键为 4 的记录。

**脏读**：指的是一个事务 A 可以读到另一个事务 B 未提交的修改。这是因为在 RU 隔离等级下 `SELECT` 语句是不加锁的。

**不可重复读**：指的是一个事务 A 读到了一条记录， 另一个事务 B 修改了这条记录并进行了提交，这个时候 A 再读这条记录就会发现这条记录变成了 B 修改之后的样子。这种情况出现的原因是在RC隔离级别下 A 事务在进行读取的时候没有加**行锁**，只有写的时候才会加**行锁**，所以 B 事务可以对相应的记录进行修改并提交。

**幻读**：指的是一个事务 A 读取了一个范围内的数据，这个时候事务 B 在这个范围内插入了一条或多条数据，并进行了提交，这个时候 A 再读取这个范围内的数据，发现多出了几条数据。

还有一种就是，第一个事务 A 对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务 B 也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作事务 A 的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

## 2. 锁算法

刚才提到了三种锁的算法：行锁（ record lock ）、间隙锁（ gap lock ）以及 next-key lock 。

行锁，顾名思义就是只对一行数据进行锁定。

间隙锁，锁住的是一段没有记录的范围，比如我有 1 、 5 、 7 三条记录，他们的间隙就有 (-∞, 1) (1, 5) (5, 7) 以及 (7, +∞) 几段。

next-key lock 是前两者的综合，还是前面的例子， next-key lock 就有 (-∞, 1] (1, 5] (5, 7] 以及 (7, +∞) 几段。在查询条件是 **唯一索引** 且是 **等值查询** 的时候，next-key lock 会退化成为行锁。

> 注意锁是在索引上实现的，加锁的时候不光会对主键索引加锁，还会对辅助索引同时加锁。

参考资料 [2] 中有在 RR 隔离等级下各种情况下 `SELECT` 和 `INSERT` next-key lock 加锁范围的实验，可以看一看。

从上面几种锁算法的加锁范围以及几种隔离级别的特点我们可以推断出：RU 不加锁，RC 加行锁而 RR 加 next-key lock。

## 3. MVCC

多版本并发控制 (Multi Version Concurrency Control, MVCC) ，快照读 (Snapshot Read) 机制，能够通过读取回滚段 (rollback segment) 中数据的历史版本，在事务读取记录的时候不用加锁，以支持超高的并发。使用 InnoDB 的时候，所有的普通 `SELECT` 语句（就是不用 `for update` 和 `in share mode` 显式加锁的）使用的都是快照读。

由于是对回滚段功能的扩展，所以 MVCC 在实现的时候并没有引入额外的空间损耗。

其核心原理是：

1. 写任务发生时，将数据克隆一份，以版本号区分；
2. 写任务操作新克隆的数据，直至提交；
3. 并发读任务可以继续读取旧版本的数据，不至于阻塞。

InnoDB的内核，会对所有row数据增加三个内部属性：

1. DB_TRX_ID，6字节，记录每一行最近一次修改它的事务ID；
2. DB_ROLL_PTR，7字节，记录指向回滚段undo日志的指针；
3. DB_ROW_ID，6字节，单调递增的行ID。

在不同事务隔离级别下， MVCC 的不同行为：

1. 事务总能够读取到，自己写入(update /insert /delete)的行记录
2. RC下，快照读总是能读到最新的行数据快照，当然，必须是已提交事务写入的
3. RR下，某个事务首次read记录的时间为T，未来不会读取到T时间之后已提交事务写入的记录，以保证连续相同的read读到相同的结果集

## 参考资料

[1] [4种事务的隔离级别，InnoDB如何巧妙实现？](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961498&idx=1&sn=058097f882ff9d32f5cdf7922644d083&chksm=bd2d0d468a5a845026b7d2c211330a6bc7e9ebdaa92f8060265f60ca0b166f8957cbf3b0182c&mpshare=1&scene=1&srcid=0904O3MkgLJI9V1xZawv2xNR#rd)

[2] [MySQL锁系列（七）之 锁算法详解](https://yq.aliyun.com/articles/108095?t=t1)

[3] [InnoDB的快照读，到底和什么相关？](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961511&idx=1&sn=2be06ffcb0335da5bf85f3e648b0fd7e&chksm=bd2d0d7b8a5a846d47e4a3b7f2fd3584f21b4007b31b9d297c960fae9dfb5003e3d9a4c6bb3e&mpshare=1&scene=1&srcid=0904jJewsIY3FdSkMHXz8wgX#rd)

[4] [InnoDB，快照读，在RR和RC下有何差异？](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961513&idx=1&sn=e955133cbd87c652d9bcbccad608190e&chksm=bd2d0d758a5a84632046e7c692064b415621ae329426adf77ae03e4a0cc55d662d6d4c543019&mpshare=1&scene=1&srcid=0904HI1g4EoFJWZMCaH3krrN#rd)