# MySQL锁机制
作者：[whlmpower](http://note.youdao.com/noteshare?id=55f74db548a53b2de6446de4c1304bde&sub=708D3D846A4340CA95454C1E3F7B846D)

## 1. MySQL锁概述
MYISAM 和MEMORY采用的是表级锁，InnoDB既支持行级锁也支持表级锁，默认采用行级锁  
表级锁：开销小，加锁快，不会出现死锁；锁力度大，发生冲突的概率高，并发度低    
行级锁：开销大，加锁慢，会出现死锁，锁力度小，发生概率低，并发度高。    
表级锁更适合**查询**为主，只有少量按索引条件更新数据的应用，如Web应用；   
行级锁更适用有**大量按索引条件**并发更新少量不同数据，同时又有并发查询的应用。

## 2. MYISAM表锁   
### 2.1 Mysql 表级锁的锁模式   
表共享读锁和表独占写锁（读读之间不加锁，读写之间、写写之间加锁）
MYISAM在执行查询语句（SELECT）前，会自动给设计的所有表加读锁，在执行更新操作（update，delete，INSERT）前，会自动给表加写锁，不需要用户显示加锁    
给MYISAM表显示加锁，一般是为了在一定程度上模拟事务操作，实现对某一个时间点多个数据的一致性读取    
在执行Lock Tables后，只能显示访问加锁的这些表，**不能访问未加锁的表**；加的是读锁，执行执行**查询操作**，不能执行**更新操作**。MYISAM总是一次性获得SQL语句所需要的全部锁。这也是MYISAM表**不会出现死锁**的原因。    
同一表出现多少次，通过与SQL语句中相同的**别名锁定多少次**    
### 2.2 并发插入
current_insert设置为0， 不允许并发插入    
current_insert设置为1，如果表中没有空洞（即表中没有被删除的行），MYISAM允许在一个进程读表的同时。另一个进程从表尾插入记录。    
current_insert设置为2，无论表中有没有空洞，都允许在表尾并发插入记录。    
利用并发插入特性来解决应用中对同一个**表查询和插入**的锁争用。   
### 2.3 MYISAM的锁调度   
默认写比读优先，即便是写操作在后。MYISAM不适合大量更新操作和查询操作应用的原因：**大量的更新操作让读操作很难得到读锁，从而永远阻塞。**   

## 3. InnoDB锁问题
InnoDB与MYISAM最大不同两点：一是支持事务，而是采用了行级锁
### 3.1 关于事务的知识
#### 3.1.1 事务的ACID

**原子性 Atomicity** ：是指一个事务要么全部执行，要么不执行。也就是说一个事务不可能只执行了一半就停止了。比如你从取款机取钱，这个事务可以分成两个步骤:1划卡，2出钱。不可能划了卡，而钱却没出来。这两步必须同时完成，要么就不完成。

**一致性 Consistency** ：是指事务的运行并不改变数据库中数据的一致性。例如，完整性约束了a+b=10，一个事务改变了a，那么b也应该随之改变。

**隔离性 Isolation** ：事务是并发控制机制，他们交错使用时也能提供一致性。隔离让我们隐藏来自外部世界未提交的状态变化，一个失败的事务不应该破坏系统的状态。隔离是通过用悲观或乐观锁机制实现的。

**持久性 Durability** ：事务的持久性是指事务执行成功以后，该事务对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚。

#### 3.1.2 数据库隔离等级

数据库有四大事务的隔离级别。

**未提交读(Read Uncommitted)** ：是最弱的隔离级别，一个事务可以读到另一个事务未提交的修改，这就会造成脏读的问题。在这个级别中，读写都是不加锁的。

**提交读(Read committed)** ：Oracle/SQL Server等数据库的默认隔离级别。提交读可以解决脏读的问题，一个事务只能读到另一个事务已经提交的修改结果。但是这可能造成不可重复读的问题，也就是在同一事务中，前后两次执行相同的语句可能得到不同的结果，因此该隔离级别也被称为不可重复读。在RC级别中，数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。

**可重复读(Repeatable read)** ：MySQL的默认隔离级别是可重复读。在本事务开始后无法看到其他事物对已有记录的更新，但是有可能看到其他事物插入的记录，这就是幻读。在Innodb中，使用了MVCC来实现这一隔离等级，在事务开始的时候，对记录创建快照，事务期间只会读与本事务版本号相符的快照，从而避免了不可重复读，其好处是读不加锁，读写不冲突(当然了，如果两个事务都要对同一记录进行修改的话还是会加排它锁)。Innodb中的可重复读和提交读均是由MVCC实现。

**串行化(Serializable)** ：所有的事务串行进行，可以避免一切脏读、不可重复读和幻读。但是并行度低，资源得不到充分的利用。读时加读锁，写时加写锁。

#### 3.1.3 多版本并发控制MVCC

**关于MVCC的实现**：MVCC是通过两个隐藏的列——生成版本号和过期版本号来实现的。下面通过增删改查几项操作来说明。
* SELECT：只查询过期版本号>当前事务版本号>生成版本号的行；
* INSERT：插入一行记录，并将当前事务版本号作为改行的生成版本号；
* DELETE：不删除记录，而是将该行记录的过期版本号改为当前的事务版本号；
* UPDATE：新插入一行记录，将插入记录的生成版本号标记为当前版本号，过期版本号改为原来的行的过期版本号，将原来的行的过期版本号改为当前事务版本号。

MVCC的读有两种，一种是读快照，另一种是当前读。快照读的时候不需要加锁，而当前读时还是会加锁。

* 快照读：
    select * from test where ... ;
* 当前读：
    select * from test where ... in share mode ;
    select * from test where ... for update ;
    insert
    update
    delete

### 3.2 获取InnoDB行锁争用情况   
通过查询information_schema数据库相关表，通过InnoDB Monitors观察锁冲突情况    

### 3.3 InnoDB行锁模式及加锁方法
共享锁   
排它锁    
InnoDB还有两种内部使用的意向锁，这两种意向锁都是表锁   
意向共享锁：事务在给一个数据行加共享锁前，必须先获得该表的IS锁    
意向排它锁：事务在给一个数据行加排它锁前，必须先获得该表的IX锁    
如果一个事务请求的锁模式与当前的锁兼容，InnoDB就该请求的锁，赋予该事务，反之，该事务就等待锁释放   
意向锁是InnoDB自动加的，不需要用户干预。对于update、delete和insert，InnoDB会自动给涉及到的数据集加排它锁，对于SELECT语句，InnoDB不会加任何锁，事务通过以下的语句给记录加共享锁或排他锁：   
1. 共享锁 SELECT \* from table_name where ... **lock in share mode**
2. 排它锁 SELECT \* from table_name where ... **for update**  
 select ... in share mode 主要用在需要数据依存关系来确认某行记录是否存在，并确保 **没有** 人对这个记录 **进行update或者delete操作** 如果当前事务也要 **进行更新** 操作，很可能造成 **死锁** ，对于锁定行记录后需要进行更新操作，应使用 **SELECT ... for update** 获得排它锁。  

### 3.4 InnoDB 行锁实现方式
InnoDB行锁是通过给**索引项**加锁来实现的，如果没有索引，InnoDB将通过隐藏的聚簇索引来对记录加锁，InnoDB行锁分为3种情形：
1. record lock  索引项加锁，防止其他事物对记录进行**修改**或者**删除**
2. gap lock 索引间隙加锁，防止其他事物对记录进行**插入**
3. next-key lock 前两种结合   
如果**不通过索引条件检索数据，那么InnoDB将对表中所有数据加锁，实际效果和表锁**是一样的    

**注意行锁使用索引的特性，否则导致大量的冲突，影响并发性能**一些例子：(不理解的话看书P332)   
1. 不通过索引条件查询数据，InnoDB会锁定表中所有记录    
2. 访问不同的行，使用相同的索引键，会出现锁冲突   
3. 表有多个索引的时候，不同的事务使用不同的索引锁定不同的行，不论使用的是主键索引、唯一索引或者普通索引，InnoDB都会使用行锁对数据加锁    
4. 基本使用了索引，但是Mysql认为全表扫描效率更高，InnoDB会对所有数据加锁，分析锁冲突的时候，检测SQL执行计划，确认是否真正使用到了索引。   

### 3.5 next-key 锁
当我们用范围条件而不是相等条件检索数据，并请求共享或排它锁时，InnoDB会给符合条件已有数据记录的索引项加锁，对于键值在条件范围内但不存在的记录，叫做间隙。InnoDB会对间隙加锁，这种锁机制就是next-key
Innodb 使用next-key锁的目的：防止幻读；满足恢复和复制的需要    
**使用范围条件的缺点：next-key锁定范围数据，造成严重的锁等待**   
（穿插日志格式：SBL RBL 待补充）

```sql
insert into target_tab select d1, name fron source_tab where name = '1'
```
这里没有使用MVCC一致读技术，而是给source\_tab加了锁，其原因在于保证恢复和复制的正确性。不加锁的话，这个过程其他事务对source\_tab更新，导致数据恢复结果错误（主从数据库不一致）。   

因为使用了锁，INSERT ... selcet... 和 create table ... SELECT... 可能会阻止对原表的修改，查询比较复杂，会产生严重的性能问题    

### 3.6 使用表锁的时机
**如果对没有建立索引的列进行搜索，则会锁住表中所有的记录，此时需要将所有的数据返回，交给MySQL服务器层，再由服务器层对返回的数进行筛选。MySQL对此也会有一些优化，当MySQL Server发现一些记录不符合规则的时候会释放那些不符合规则的行的锁**
**事务需要更新大部分或者全部数据，表比较大。**    
**事务涉及多个表，比较复杂，很可能引起死锁，造成大量的事务回滚**  
应用中的事务不能太多，否则就一个使用MYISAM表了    
使用表锁的注意事项：
1. 表锁不是InnoDB存储引擎层管理的，而是由Mysql server 管理的，仅当 autocommit = 0 、innodb_table-lock = 1 时, InnoDB才能感知mysql server加的锁，mysql server也才能感知InnoDB加的锁。
2. 使用lock table的正确方法
```sql
set autocommit = 0;
lock tables t2 write, t2 read, ...;
[do something with table1 and table2];
commit;
unlock tables;
```
事务结束前，**不要使用unlock释放表锁，因为unlok tables 会隐含地提交事务**。反之则不行，commit rollback不能释放表级锁。    

### 3.7 关于死锁
MYISAM总是一次获得所需的全部锁，要么满足，要么等待，不会出现死锁。但是在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，这就决定了InnoDB中发生死锁是可能的。    
发生死锁后，InnoDB一般都能自动检测到，并使一个**事务回退**，另一个事务**获得锁**，继续完成事务。但是在涉及**外部锁或涉及表锁**的情况下，InnoDB不能完全自动检测到死锁，这时需要通过设置超时等待参数 innodb\_lock\_wait\_timeout。     
几个避免减少锁冲突以及死锁的实例：   
1. 不同应用程序会并发存取多个表，应尽量约定以**相同的顺序**来访问表。    
2. 在程序批处理数据的时候，实现对数据进行**排序**，保证每个线程**按照固定顺序**来处理数据。
3. 在事务中，如果要更新记录，应该**申请足够的锁级别**，而不是先申请共享锁，再申请排它锁，因为在申请排它锁时，另一个事务获取了相同记录的共享锁，从而造成锁冲突，甚至死锁。（上文有阐述）   
4. 尽量使用**较低的隔离级别**，使用readcommit解决select for update 问题
5. 设计良好的**索引**，加锁更加准确，减少锁冲突
6. 选择合理的**事务大小**，小事务锁冲突的几率更小
7. 尽量以**相等条件**访问数据，避免next-key锁对并发影响  
