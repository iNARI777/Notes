### 1. MySQL主从复制

1. 首先**主库**在事务提交的时候会把数据变更作为时间Events记录在二进制日志文件中Binlog中；同时MySQL主库也会根据sync_binlog参数指定的时间，将Binlog刷入磁盘；
2. **主库**会推送Binlog到从库的Relay log，之后**从库**根据Relay Log的内容重做数据变更的操作，通过逻辑复制的方式来进行主库和从库的同步。

> 要注意主从复制是异步进行的，因此实时性不高。

从库的用途：
1. 在主库挂掉的时候可以切换到从库继续提供服务；
2. 在实时性要求不高的应用场景下可以使用从库作为读库，分担主库的读写压力，但是对于实时性要求很高的应用还是要从主库读取；
3. 在备份数据库的时候可以使用从库进行备份，避免备份主库的时候影响服务。

> 两个日志Binlog和Relay Log在格式上都是一样的，以二进制的方式记录了数据库的Create, Drop, Insert, Update, Delete等操作，而不会记录Select操作。两者的区别是从库的SQL线程完成Relay Log中的事件之后就会删除Relay Log。

有三种模式：Statement、Row和Mix。Statement模式是记录SQL语句，Row是记录行的变化，Mix是二者皆有。默认是Statement模式，这种模式下日志的体积较小。

### 2. MySQL优化

**Explain结果的分析**

type列的内容有以下几项，性能依次提高：
1. ALL：全表扫描；
2. index：索引全扫描；
3. range：索引范围扫描，常见于<, >, <=, >=和between；
4. ref：使用**非唯一索引**扫描或**唯一索引的前缀**扫描，返回某个单独值的匹配行；
5. eq_ref：与ref类似，不过使用的索引是**唯一索引**，常出现在以唯一索引为匹配条件的多表连接操作中；
6. const/system：表中最多只有一个行匹配，常见于对于主键、唯一索引的查询；
7. NULL：不需要进行索引就可以得到结果。

**InnoDB中可以使用索引的典型场景**

1. 全值匹配：对蓑尹忠的所有列都列出具体值，列出等值匹配条件；
2. 匹配值的范围查询：对索引的值进行范围查找；
3. 最左前缀匹配：仅仅使用索引中最左边的几个列进行查找；
4. 覆盖索引查询：查询的条件和查询得到的内容均在索引中，不需要进行回表；
5. 匹配列前缀：使用列的前缀进行匹配；
6. 查询空列如<列名> is null的时候也可以使用这一列的索引。

**不能够使用索引的典型场景**

1. 以%开头的like查询；
2. 对数据类型进行了隐式转换的时候，如列id类型为char，但是查询的时候没有给id的值加引号，就会导致int型隐式转换为char型，这个时候就无法使用索引了；
3. 不符合最左前缀匹配的查询；
4. MySQL估计使用索引会比全表扫描慢的时候会放弃使用索引；
5. 使用or分割开的条件中一部分使用了索引而另一部分不使用索引的时候就都不会使用索引。

## 3. 事务隔离机制与MVCC

事务有四重隔离级别，分别是未提交读、提交读、可重复读以及串行化。

* **未提交读**在事务中可以读到其他事务未提交的修改，完全破坏了事务的隔离性；
* **提交读**在事务中可以读到其他事务中已提交的修改，有不可重复读的问题会出现，在SQL Server、Oracle中是默认的隔离级别；
* **可重复读**在事务中不会读到其他事务已提交的修改，但是可能读到其他事务中新插入的数据，也就是幻读。读加读锁，写加写锁；但是在MySQL中，该级别下由于默认使用next-key锁算法，解决了幻读的问题。
* **串行化**在事务中读加读锁，写加写锁，使得事务串行执行，是最高的隔离等级。

MVCC为多版本并发控制，在原理上是在通过保留多个版本的数据，并保存行数据的**开始版本号**以及**过期版本号**，配合上事务的版本号来保证读的时候读相应版本的数据的。而在实现上是直接使用undo log来实现的，所以其实现上并没有额外的开销。

值得注意的是在**提交读**隔离级别下，MVCC总是读被锁定行中版本号最新的一个；而在**可重复读**隔离级别下，MVCC总是读版本号与事务版本号相同的一个。

## 4. MySQL的Redo log和Undo log

### 4.1 Undo log

undo日志用于存放数据修改被修改前的值，假设修改 `tba` 表中`id=2`的行数据，把`Name='B'`修改为`Name = 'B2'` ，那么undo日志就会用来存放`Name='B'`的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。

对数据的变更操作，主要来自 `INSERT UPDATE DELETE`，而UNDO LOG中分为两种类型，一种是 INSERT_UNDO（INSERT操作），记录插入的唯一键值；一种是 UPDATE_UNDO（包含UPDATE及DELETE操作），记录修改的唯一键值以及old column记录。

### 4.2 Redo log

当数据库对数据做修改的时候，需要把数据页从磁盘读到buffer pool中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容不一致，称buffer pool的数据页为dirty page 脏数据，如果这个时候发生非正常的DB服务重启，那么这些数据还没在内存，并没有同步到磁盘文件中（注意，同步到磁盘文件是个随机IO），也就是会发生数据丢失，如果这个时候，能够在有一个文件，当buffer pool 中的data page变更结束后，把相应修改记录记录到这个文件（注意，记录日志是顺序IO），那么当DB服务发生crash的情况，恢复DB的时候，也可以根据这个文件的记录内容，重新应用到磁盘文件，数据保持一致。

这个文件就是redo log，用于记录数据修改后的记录，顺序记录。它可以带来这些好处：

* 当buffer pool中的dirty page 还没有刷新到磁盘的时候，发生crash，启动服务后，可通过redo log找到需要重新刷新到磁盘文件的记录；
* buffer pool中的数据直接flush到disk file，是一个随机IO，效率较差，而把buffer pool中的数据记录到redo log，是一个顺序IO，可以提高事务提交的速度。

**Redo log和Binary log的区别：**

redo log 是存储引擎层产生的，而binary log是数据库层产生的。假设一个大事务，对tba做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而binary log不会记录，知道这个事务提交，才会一次写入到binary log文件中。binary log的记录格式有3种：row，statement跟mixed，不同格式记录形式不一样。