### 1. MySQL主从复制

1. 首先**主库**在事务提交的时候会把数据变更作为时间Events记录在二进制日志文件中Binlog中；同时MySQL主库也会根据sync_binlog参数指定的时间，将Binlog刷入磁盘；
2. **主库**会推送Binlog到从库的Relay log，之后**从库**根据Relay Log的内容重做数据变更的操作，通过逻辑复制的方式来进行主库和从库的同步。

> 要注意主从复制是异步进行的，因此实时性不高。

从库的用途：
1. 在主库挂掉的时候可以切换到从库继续提供服务；
2. 在实时性要求不高的应用场景下可以使用从库作为读库，分担主库的读写压力，但是对于实时性要求很高的应用还是要从主库读取；
3. 在备份数据库的时候可以使用从库进行备份，避免备份主库的时候影响服务。

> 两个日志Binlog和Relay Log在格式上都是一样的，以二进制的方式记录了数据库的Create, Drop, Insert, Update, Delete等操作，而不会记录Select操作。两者的区别是从库的SQL线程完成Relay Log中的事件之后就会删除Relay Log。

有三种模式：Statement、Row和Mix。Statement模式是记录SQL语句，Row是记录行的变化，Mix是二者皆有。默认是Statement模式，这种模式下日志的体积较小。

### 2. MySQL优化

**Explain结果的分析**

type列的内容有以下几项，性能依次提高：
1. ALL：全表扫描；
2. index：索引全扫描；
3. range：索引范围扫描，常见于<, >, <=, >=和between；
4. ref：使用**非唯一索引**扫描或**唯一索引的前缀**扫描，返回某个单独值的匹配行；
5. eq_ref：与ref类似，不过使用的索引是**唯一索引**，常出现在以唯一索引为匹配条件的多表连接操作中；
6. const/system：表中最多只有一个行匹配，常见于对于主键、唯一索引的查询；
7. NULL：不需要进行索引就可以得到结果。

**InnoDB中可以使用索引的典型场景**

1. 全值匹配：对蓑尹忠的所有列都列出具体值，列出等值匹配条件；
2. 匹配值的范围查询：对索引的值进行范围查找；
3. 最左前缀匹配：仅仅使用索引中最左边的几个列进行查找；
4. 覆盖索引查询：查询的条件和查询得到的内容均在索引中，不需要进行回表；
5. 匹配列前缀：使用列的前缀进行匹配；
6. 查询空列如<列名> is null的时候也可以使用这一列的索引。

**不能够使用索引的典型场景**

1. 以%开头的like查询；
2. 对数据类型进行了隐式转换的时候，如列id类型为char，但是查询的时候没有给id的值加引号，就会导致int型隐式转换为char型，这个时候就无法使用索引了；
3. 不符合最左前缀匹配的查询；
4. MySQL估计使用索引会比全表扫描慢的时候会放弃使用索引；
5. 使用or分割开的条件中一部分使用了索引而另一部分不使用索引的时候就都不会使用索引。