## 一、服务器间的通信流程
本项目主要涉及到四台服务器，四台服务器之间的通信流程如下图所示：

![](images/1.png)

1.	首先由远程服务器1向本地服务器提交参数，参数包括图片URL、Time、相机Id等。
2.	本地服务器将接收到的图片URL后，给远程服务器1一个回应success，并将参数信息添加到数据库。
3.	本地服务器根据服务器1提交的URL参数到远程文件服务器请求获取相应图片。
4.	远程文件服务器将相应图片返回给本地服务器，并在本地服务器上处理。
5.	本地服务器将处理结果上报给远程服务器2，一个通信流程完成。

## 二、本地服务器内部处理过程

本项目的主要流程在本地服务器上，本地服务器上的流程如下：
1. 获得参数：接受到远程服务器1传递的参数后进行完整性校验，并回复success，，并将参数信息添加到数据库以及Redis的任务队列，然后调用下载任务。
2. 下载任务首先判断是否有其他线程在访问任务队列。如果没有，则开始执行下载任务，从Redis任务队列中取出，放入线程池中进行下载（暂时使用了BIO，下一步考虑用NIO重写这步）。如果有线程正在访问任务队列，则直接从该方法中返回。此处没有使用悲观锁，而是使用了一个乐观锁。
3. 在上一步中，线程池中每个下载完图片的线程会调用Python脚本对本线程下载好的图片进行处理，Python脚本会对图片进行人数统计，处理完成后Python脚本在调用本地服务器的接口call_back，将统计结果传递给该接口。
4. 回调接口首先将根据处理图片的id将数据库中的相应行的isDealt置为1并将统计结果计入数据库，然后对结果进行上报。
5. 将4中得到的返回值上报给远程服务器2，若成功接收到回复信息，则将标志位(isReport)更为真。

## 三、数据库表设计

数据库名：seneric_region

数据库中使用了一个表photo_data，字段如下：

* id：int类型，每个图片（PhotoData）有单独的id，通过Redis生成；
* cameraCode：varchar类型，相机编号，景区每个相机有其唯一的编号，用于表示图片来源；
* photoUrl：varchar类型，代表图片的url，服务器根据此url下载图片进行处理；
* callTime：第一步中服务器调用本服务器接口的时间；
* isRequired：int类型，有0和1两个值，如果图片还未下载，该项为0，如果下载完成，此项改为1；
* isDealt：int类型，有0和1两个值，如果图片已经由Python脚本处理，此项值为1；
* isReported：int类型，有0和1两个值，如果图片解析结果已经上报，此项值为1；
* numOfPeo：varchar类型，内容为图片经Python脚本解析后得到的图片中的人数。

将id设置为该表的主键，用于使用id的高效查询。


（还没做）同时根据业务需要，会查询isRequired/isDealt/isReported的值为0的项，同时对callTime有要求，如获取近半小时内未下载、未处理或为上报的数据，重新进行操作。为了提高查询效率，增加了复合索引，索引定义的顺序如下：isRequired、isDealt、isReported最后是callTime。

如此定义的原因如下：

1. 根据业务逻辑，三个业务完成标志只有在前一个为1的情况下，本标志才有可能置为1。假如我要查找未处理的条目，那么不光要保证isDealt为0，还要保证isRequired为1。因此将三个业务完成标志按顺序放入索引（不按顺序也行，三个业务完成标志都要用上）；
2. 通过时间查找是一个范围索引，因此需要将时间callTime放在最后，保证复合索引能够在有callTime范围查找的时候仍能够使用最右边的几个索引，提高效率。

## 4. ID生成策略

由于要同时将图片信息放入Redis任务队列和MySQL中，但是后续下载操作需要直接从Redis中获取图片ID，这几需要保证Redis中和MySQL中相同的图片要有相同的ID。图片可能有不同的来源，因此不能使用来源的编号来作为图片的ID。考虑过的方案有以下几种：

1. 使用URL作为图片的id，但是图片URL太长，不利于索引，因此pass掉了这种方案；
2. 首先将图片信息存入MySQL，然后马上从MySQL中取出这些信息放入Redis，stupid，pass；
3. 使用Redis作为ID生成器，在收到图片信息的同时为这个信息生成一个ID。

最终采用了第三种方法。但是第三种方法面临一个问题就是重启后id丢失的问题，我们知道Redis是一个内存数据库，关机重启之后内存中的数据会丢失。这个时候就要用到Redis的持久化机制，同时设置Redis 的RDB和AOF机制，记录每秒的变化并持久化到磁盘，保证Redis重启之后仍能正常生成id。

但是还有一个问题，万一服务器关机的时候最后一秒的数据没有持久化到硬盘上，就会导致id重复的情况出现。这个时候有两种方法可以解决，一种是将Redis的AOF的appendfsync从everysec改为always。但是这会影响Redis 的性能，不过目前Redis压力不大，可以接受。第二种方法是在MySQL中新建一个表专门用来记录id，在第一步中将图片信息存入MySQL的同时打开一个事务，将图片信息存储和id编号存储放在同一个事务中。在服务器重启之后先检查MySQL中的id，并将Redis的ID编号更新为这个值就可以了。

## 附加
服务器中 /root/apps/start.sh 为启动脚本，同时还有stop.sh 和 kill.sh
