# 缓存设计

## 1. 明确目的

通常，对于MySQL等关系型数据库的访问相对于内存访问来说，代价是要大得多的，因为数据库查询经常会涉及到**磁盘IO**。因此在出现大量的**查询数据库请求**的时候，很容易导致数据库服务器性能跟不上导致服务崩溃，所以我们会想到将之前查询过的内容缓存在内存中，如果下次查询操作查询的是相同的东西，服务器就可以直接从内存缓存中取出相应数据，而不需要从数据库中再次查询，从而减小数据库服务器的压力。

## 2. 缓存的使用过程

**命中/未命中：**在进行数据查询的时候，如果我们能够在缓存中找到相应的条目，我们就称这是一次**“命中”**。如果没有命中，则仍需要从数据库中读取相关的数据，并将其加入缓存。

**缓存淘汰/更新：**在数据更新的时候，我们需要将缓存中的数据进行更新或淘汰。一般来说缓存淘汰使用的比较多，因为缓存淘汰最多只会增加一次缓存miss，实现比较简单。缓存更新的代价要根据业务来看，如果缓存的内容是一个很复杂的过程，那么更新缓存的代价就会很大，在这种情况下不建议使用缓存更新。

**先淘汰缓存，再写入数据库：**因为如果反过来，发生缓存淘汰失败的情况，就会导致数据库数据已经更新，但是缓存未更新这种数据不一致情况的发生。

**内存空间不足时缓存淘汰顺序：**涉及到几种算法——LRU、FIFO、LFU，也有可能使用超时删除。

## 3. 缓存设计上的优化

### 3.1 缓存粒度

就是一次要缓存的数据量的多少，比如数据库表中一行有100列，那么就要考虑要不要把这100列都放入缓存。这里的取舍是要根据实际应用来决定的。

### 3.2 缓存穿透问题

缓存穿透指的是**要查询的数据在缓存中和数据库中都不存在。**这样的话每次查询还是会穿过缓存查询数据库，这种情况常见于爬虫攻击或者业务逻辑有问题。这种问题的解决可以通过**缓存空值**或者使用**布隆过滤器**来解决。

### 3.3 雪崩优化问题

为了保护数据库层，我们使用了缓存层，但是如果缓存层崩溃了，所有的查询又会重新落回到数据库层，很容易造成数据库层同时崩溃。这时就要保证缓存层的高可用。