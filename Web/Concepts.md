# Web 相关的基础知识

## 1. Cookie 基本知识

Cookie 是一段存放在 **浏览器** 中，用于存放 **用户** 相关信息的一段数据。而浏览器是根据 **服务器** 的 **响应头** 的指示来记录 Cookie 的。

当用户发送请求给同一个 **域** 的时候，浏览器会自动将 Cookie 添加到请求的请求头中发送给服务器。Cookie 在请求头中的格式是

  cookie:key1=value1; key2=value2; key3=value3

可见， Cookie 可以用作一个存储工具，但是为了避免 cookie 的滥用，大多浏览器厂商都会对 cookie 的大小和数量作出限制，比如每个 cookie 大小最大为 4KB，每个域下的 cookie 最多可以有 20 个等。

**Cookie 的发送**

每次浏览器在发送 http 请求的时候都会检查一下在这个域中是否有相应的 cookie，如果有相应的 cookie，浏览器就要将其放入 `request header` 中。

**Cookie 的添加**

Cookie 的添加可以在服务端的 **响应头** 中的 `set-Cookie` 字段设置，每个 `set-Cookie` 可以设置一个 cookie。

Cookie 的设置也可以在浏览器端通过 JavaScript 进行设置，。

**Cookie 的属性**

每个 cookie 除了存储的内容之外，浏览器还会存储每一个 cookie 的属性。

* expires ：用来设置有效时间
* domain+path ：共同构成了 URL，这个 URL 用来表示一个 Cookie 能够被哪些 URL 访问。 domain 的默认值为这个 cookie 所在的域名，而 path 的默认值为设置该 cookie 的页面所在的路径。
* httpOnly ：用来设置该 cookie 只能被 http 请求访问，而 JavaScript 等其他方法无法访问该 cookie 。
* secure ：这个配置要求服务器支持 https 协议，因为这个配置是用来将 cookie 加密用的。

## 2. 限流

限流最容易想到的方法就是维护一个每秒钟最大请求量，请求来了请求量 +1 ，如果请求量超过了最大请求量，则拒绝服务，每秒钟会清空这个请求量。但是这个方法有一个比较致命的缺陷，就是在前一秒的最后和后一秒的最开始都达到了最大请求量的话，实际的每秒请求的数量就变为了每秒最大允许请求量的 2 倍，超出了服务器能够处理的能力。所以就有了后面两种算法。

### 2.1 漏桶算法

漏桶算法的核心思想是规定一个漏桶的容量，流量现灌入漏桶，同时以一定的速率处理漏桶中的请求，如果请求过快就会溢出漏桶，进行相应的服务拒绝策略（比如直接丢弃）。但是使用漏桶算法在有的时候对网络的利用效率不高，比如在资源充足的时候，消耗请求的速率仍然是一个固定的速率，无法充分利用资源。而令牌桶算法更适合这种情况。

### 2.2 令牌桶算法

令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。 令牌桶的另外一个好处是可以方便的改变速度。 一旦需要提高速率，则按需提高放入桶中的令牌的速率。

Guava 的具体实现可以看[这里](https://www.cnblogs.com/LBSer/p/4083131.html)。
