# 内部类相关知识点

## 1. 内部类的分类

### 1.1 成员内部类

成员内部类，顾名思义，就是像定义成员方法和成员变量那样，定义在另一个类中的类。
	

	class Outer {
	    class Inner {
	        public void innerMethod() {
	            System.out.println("这是内部类的方法");
	        }
	    }
	    public void outMethod() {
	        System.out.println("这是外部类的方法");
	    }
	}

其中，类Inner就是类Outer的内部类，类Outer就是类Inner的外部类。

像成员方法和成员变量一样，成员内部类前也可以加public、protected、private的权限访问修饰符，其含义也和修饰字段和方法的相同，如果我们想使用成员内部类时，需要注意它的权限访问的范围。

**使用内部类时的形式**

* 类的在外部类中使用内部类的时候直接使用类名就可以；
* 在外部类以外使用的时候需要使用`Outer.Inner`的形式。

**创建内部类对象的形式**

* 在外部类中创建内部类对象的时候直接`new`就行；
* 在外部类以外的地方使用如下的形式进行内部类对象的创建：
	

	Outer outer = new Outer();
	Outer.Inner inner = outer.new Inner();

**内部类的特点**

成员内部类中维护了一个外部类对象的引用！成员内部类可以访问外部类的**所有**成员，包括private成员。

注意：成员内部类中不能有static成员。因为成员内部类每回**外部类对象被创建**的时候都会加载一次，这与static成员只有一份的原则相违背。但是可以有static final的**基本类型**的域，因为在编译的时候这个域会被当做常量来对待。引用类型就不行。

如果要显式使用外部类的变量的话可以这样指定：
	
	class Outer {
    	private int i = 1;
    	class Inner {
        	private int i = 2;
        	public void accessOuterField() {    //访问外部类对象的成员变量
            	System.out.println("外部类和内部类中拥有同名字段i：");
            	System.out.println("i = " + Outer.this.i);  //显式地指定外部类类名
        	}
    	}
	}

即`Outer.this.i`就可以了。

### 1.2 方法内部类

方法内部类就是定义在一个类的方法(成员方法和静态方法均可)中的类。

	public class Outer {
	    public void method() {  //外部类的一个成员方法
	        class Inner {   //方法内部类
	            public void innerMethod() {
	                System.out.println("这是内部类的方法");
	            }
	        }
	    }
	    public void outMethod() {
	        System.out.println("这是外部类的方法");
	    }
	}

由于是在方法内部定义的，所以方法内部类就不能使用public、private和protected修饰了。并且其作用域就在方法内部，出了方法就不能使用了。

**方法内部类的特点**

1. 成员方法中： 
由于方法内部类在外部类的成员方法中定义，想创建内部类对象，必须对外部类的成员方法进行调用，所以可以在创建对象的时候**获得到外部类对象的引用**，所以类似成员内部类，也具有如下的特点：
* 成员内部类对象包含外部类对象引用。
* 成员内部类的成员方法可以直接访问外部类所有成员。
* 成员内部类中不能定义static的方法和字段。
2. 静态方法中： 
静态方法中定义的方法内部类由于在创建对象的时候无法获取到外部类对象的引用，所以木有上边的特点。

共有特点：
无论方法内部类是在外部类的成员方法中定义，还是在静态方法中定义，都具有这个非常重要的特点：

* 方法内部类的成员方法**不能改变**该内部类所在**外部类方法**的**局部变量**（包括方法参数以及方法内定义的变量）的值。

> 因为方法内部类的方法可以通过一些方法扩大其作用域，但方法的局部变量的作用域只局限在方法中。如果不允许方法内部类修改外部的变量的话，就可以将这些变量看做常量来进行访问，而编译器实际上也是这样做的。在编译的时候将对方法内部类外部的变量当做常量。所以在JDK8以前，方法内部类要访问的变量都是要加上final的，但是JDK8以后放宽了限制，不需要加final了，只要不修改外部局部变量的值就可以。

### 1.3 静态内部类

静态内部类就是像定义静态方法和静态变量那样，定义在另一个类中的类。也就是要在定义类的时候加`static`修饰。
	
	public class Outer {
    	private static class Inner {   //方法内部类
        	public void innerMethod() {
            	System.out.println("这是内部类的方法");
        	}
    	}
    	public void outMethod() {
        	System.out.println("这是外部类的方法");
    	}
	}

可见，静态内部类也是可以使用public, private, protected等权限访问修饰符来修饰的。

静态内部类的创建很简单：

	Outer.Inner inner = new Outer.Inner();

**静态内部类的特点**

1. 创建静态内部类对象的时候不需要先创建外部类的对象，**如果仅仅创建了静态内部类的对象，而没有引用外部类相关的域，不会对外部类进行加载**；
2. 静态内部类不能访问外部类的**成员变量**和**成员方法**；
3. 静态内部类中可以定义静态域。

**接口中定义的内部类**

接口中定义的内部类默认是`public static`的。

### 1.4 匿名内部类

匿名内部类就是没有名字的内部类，把类的定义和创建对象过程结合到了一起。匿名内部类的定义如下所示：
	
	public class Outer {
    	public void method() {
        	Base base = new Base() {
            	@Override
            	public void baseMethod() {
                	System.out.println("这是Base的一个木有名字的类的baseMethod方法");
            	}
        	};
        	base.baseMethod();  //调用匿名内部类的成员方法
    	}
    	public static void main(String[] args) {
        	new Outer().method();
    	}
	}

其实这个过程等价于你先去创建一个Base类的**子类**，然后创建一个子类对象。

**匿名内部类的特点**

1. 匿名内部类可能属于成员内部类，也有可能属于方法内部类，看其定义的位置。相应的匿名内部类有相应的性质；
2. 匿名内部类没有名字，所以也没办法定义构造方法，但是可以调用父类的构造方法。就在new 父类的时候加上方法参数就可以了；
3. 一个匿名内部类只能有一个对象；
4. 如果匿名内部类的父类是抽象类或接口的话需要实现所有的抽象方法与接口方法。

## 2. 内部类的作用

### 2.1 更加面向对象的设计

让类的功能尽量的单一。将类内部的实现尽量隐藏起来。

### 2.2 可以间接实现多重继承的功能

每个内部类也可以单独继承一个父类或者实现多个父接口，但是同时，它也可以访问外部类中的方法和域。

### 2.3 回调方法的升级

通过内部类，可以让定义回调方法的时候不将本类的对象传递给被调者，而只传递一个本类的内部类的一个对象。这样可以避免被调者访问到调用者不想被访问到的方法的情况。

## 3. 总结

1. 所谓内部类，其实就是一个类的定义放在了另一个类定义的内部。
2. 从内部类定义的地方来区分，内部类可分为成员内部类、方法内部类、静态内部类。
3. 成员内部类就是像定义成员方法和成员变量那样，定义在另一个类中的类。 
它具有这几个特点：

* 成员内部类对象包含外部类对象引用
* 成员内部类的成员方法可以直接访问外部类所有成员
* 成员内部类中不能定义static的方法和字段
* 创建对象时需要外部类对象引用，语法结构式：outer.new Inner()。

4. 在内部类对象中访问外部类对象引用时，需要显式地加外部类类名：Outer.this

5. 方法内部类就是定义在一个类的方法(成员方法和静态方法均可)中的类。 
如果在该方法内部类所在的作用域之外使用它会编译错误的。
在外部类成员方法中定义的方法内部类拥有和成员内部类一样的特点。

特别注意：方法内部类的成员方法不能改变该内部类所在外部类方法的局部变量的值

5. 静态内部类就是像定义静态方法和静态变量那样，定义在另一个类中的类。 
静态内部类的使用和普通的类没啥两样，只是在外部类使用时需要指明外部类名，比如：Outer.Inner inner = new Outer.Inner()

6. 匿名内部类就是没有名字的内部类，把类的定义和创建对象过程结合到了一起。

* 匿名内部类中不可以定义构造方法，但是可以在创建对象的时候调用父类的构造方法
* 一个匿名内部类只能有一个对象
* 匿名内部类的父类如果是接口或者是抽象类的话，那必须实现父类中所有的抽象方法
* 匿名内部类的成员方法中使用到它所在外部类方法的局部变量时，不能修改该局部变量的值
* 
7. 内部类的使用主要考虑到下边这几点：
* 更加面向对象的设计
* 多重继承
* 回调机制
 
8. 内部类的继承需要注意子类的构造方法中需包含外部类对象引用。

9. 内部类没有多态特性

10. 编译带有内部类的.java文件时候，外部类类名和内部类类名以$符隔开，如果时匿名内部类时用数字代替。

# 参考资料

本文摘自[内部类](https://www.zybuluo.com/xiaohaizi/note/917272)，看不了的话就关注微信公众号“我们都是小青蛙”