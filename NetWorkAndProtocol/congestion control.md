# TCP拥塞控制

## 1. TCP的交互数据流

#### 1.1 延迟ACK

通常TCP在接到数据的时候不会立刻发送ACK，以便将ACK与需要延该方向传输的数据一同发到对端（捎带ACK），TCP的通常实现都是讲采用200ms作为延时。

#### 1.2 Nagle算法

使用TCP协议的交互性程序中经常会有小分组(tinygram)，这些小分组的载荷可能只有1byte，但是整个分组加上TCP头的20byte和IP头的20byte，共会产生41byte，这就会造成极大的浪费。

在局域网中的小分组可能不会造成很大影响，但是在广域网上，如果小分组太多的话就会很容易造成拥塞。**Nagle算法**就是为了解决这一问题而诞生的。这也是一种拥塞控制算法。

> Nagle算法主要是避免发送小的数据包，要求TCP连接上最多只能有一个未被确认的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的小分组，并在确认到来时以一个分组的方式发出去。

```
// Nagle算法的伪代码
if there is new data to send  
  if the window size >= MSS and available data is >= MSS  
    send complete MSS segment now  
  else  
    if there is unconfirmed data still in the pipe  
      enqueue data in the buffer until an acknowledge is received  
    else  
      send data immediately  
    end if  
  end if  
end if 
```

但是对于交互性要求非常高的应用来说，Nagle算法可能就不太适合了，会有明显的延迟，这个时候可以禁用Nagle算法来解决这一问题。

## 2. TCP的成块数据流

#### 2.1 滑动窗口协议

**停止等待协议**：是tcp保证传输可靠的重要途径，“停止等待”就是指发送完一个分组就停止发送，等待对方的确认，只有对方确认过，才发送下一个分组。

**滑动窗口协议**：由于停止等待协议每次发送一个分组都需要等待ACK，因此势必会降低吞吐量。为解决这一问题，滑动窗口协议应运而生。滑动窗口协议允许发送方在停止并等待确认之前可以连续发送多个分组，此方法可以加速数据的传输。

**自动重传请求**（Automatic Repeat-reQuest，ARQ）：OSI模型中数据链路层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ可能包括*停止等待ARQ协议*、*回退ARQ*和*连续ARQ协议*，错误检测（Error Detection）、正面确认（Positive Acknowledgment）、超时重传（Retransmission after Timeout）和 负面确认及重传（Negative Acknowledgment and Retransmission）等机制。

#### 2.2 发送快于接收方处理速度

在使用滑动窗口协议的时候，如果发送方的发送速度快与接收方的处理速度的时候，接收方在发送确认的时候会减小win(滑动窗口大小)的值，这个时候发送方会对一次发送的分组数进行调整，减小发送的组数，如果接收方的确认帧的win为0，发送方则会停止发送。接收方处理完成后会发送另一个ACK(称为窗口更新)，表明可以继续接受数据。

#### 2.3 慢启动机制

如果发送方和接收方之间存在多个路由器或者链路的速度较慢的时候，中间的一些路由器就必须缓存分组，并且有可能耗尽内存空间。所以我们就需要慢启动的机制来使新分组进入网络的速率与另一端返回的确认的速率相同。

慢启动为发送方的TCP添加了一个拥塞窗口cwnd。当与另一个主机建立TCP连接的时候，拥塞窗口被初始化为1个报文段，每收到一个ACK，拥塞窗口就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段为单位增加）。

> 与cwnd相对的是rwnd，也就是接收窗口，cwnd是发送端维护的，而rwnd是接收端维护的。在发送端发送数据包的时候，取cwnd和rwnd中较小的一个作为这次发送的报文数。

## 3. TCP的超时与重传 拥塞控制

#### 3.1 超时重传

TCP提供可靠的运输层，他是用的方法之一就是确认从一端到另一端接收到的数据。但是数据和确认都有可能丢失，TCP通过在发送时设置一个定时器来解决该问题，如果发送方定时器溢出了还没有收到确认，就会重传该数据。

> TCP不会对没有数据的ACK报文进行确认，只会确认那些有数据的报文。

对于每个链接，TCP都会维持4个定时器：
1. **重传定时器**：使用于当希望收到另一端的确认，是本节重点讨论的定时器；
2. **坚持定时器**：使窗口大小信息保持流动，比如当接收端的接受窗口为0的时候，发送端就会暂停发送，但是如果接收端的处理完了之前的信息，发送了窗口通告报文，如果此报文丢失了，数据就无法正常传输了。为解决这种问题，发送方会维持一个坚持定时器，每隔一段时间就会发送一个窗口探查报文；
3. **保活定时器**：可以检查一个空闲连接的另一端何时崩溃或者重启。如果连接的一端在连接空闲一段时间之后发送一个探测报文，以确认对方是否在线，如果对方在线，会发送相应，保活定时器在2小时候再触发；如果对方崩溃，则无法收到正常回复，每个75s再发送一次，共发送9次，若都无回应，连接超时；如果对方崩溃后已经重启，则会发送RST重置TCP连接；
4. **2MSL定时器**：用于测量一个连接处于TIME_WAIT状态的时间，以防止发往服务器的最后一个ACK丢失，导致连接无法关闭。

#### 3.2 拥塞控制算法

分组丢失的标志有两种：**发生超时**和**接收到重复的ACK**。

快启动方法要求每收到一个ACK，cwnd就加1；而拥塞避免算法是收到一个ACK，让cwnd增加1/cwnd。
> 也就是说快启动方法在一个往返后会增长cwnd，而拥塞避免只会增加1。

拥塞避免算法和慢启动算法需要对每个连接维持了两个变量：cwnd和慢启动门限ssthresh。其过程如下：
1. 对一个给定的连接，初始化cwnd为1个报文段，ssthresh为65535个字节（慢启动）；
2. TCP输出程序的输出不能超过cwnd和接受窗口rwnd大小。拥塞避免是发送方的流量控制，而通告窗口则是接收方的流量控制，前者是发送方对网络拥塞情况的估计，后者与接收方可用于连接的缓存大小有关；
3. 当拥塞发生的时候（也就是有分组丢失的情况发生的时候），ssthresh设置为当前窗口大小的一半。此外，如果是超时引发的拥塞，则将cwnd设置为1个报文段（开始慢启动）；
4. 当新的数据被确认，cwnd就会增加，但是增加的方法依赖于我们是否正在进行慢启动或者拥塞避免。如果cwnd小于ssthresh，则正在进行慢启动，否则就是在进行拥塞避免。

#### 3.3 快速重传和快速恢复

在接收端收到一个失序的报文的时候，TCP会立即产生一个重复ACK（这也就是为什么会收到重复ACK的原因）。**这个ACK不应该被延迟**。

由于接收到了三个重复ACK，证明两台主机间还有数据流动，没有必要突然将数据流量减小到非常小，因此不需要使用慢启动算法，我们转而使用快速重传和快速恢复算法：

1. 当收到第三个重复ACK的时候，将ssthresh设置为当前窗口的一半，重传丢失的报文，设置cwnd为ssthresh加上3倍的报文段大小；
2. 每次受到另一个重复的ACK的时候，cwnd增加1个报文段大小并发送1个分组（如果新的cwnd允许发送）；
3. 当下一个确认新数据的ACK到达时，设置cwnd为ssthresh。这个ACK应该是对丢失的分组和收到的第1个重复ACK之间所有中间报文的确定。这一步采用的是拥塞避免。

这部分可见[这篇博客](https://coolshell.cn/articles/11609.html)。